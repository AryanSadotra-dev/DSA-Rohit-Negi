/*
===============================================================================
üìò DSA LECTURE NOTES ‚Äì DAY 24
INSERTION SORT
(DSA ‚Äì 180 Days Coding Challenge)
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready)
===============================================================================

‚ö†Ô∏è These notes are NOT a definition dump.
‚ö†Ô∏è These notes reconstruct the teacher‚Äôs EXACT thinking process.
‚ö†Ô∏è Card-game analogy, repetition, dry-runs, mistakes & fixes are INTENTIONAL.
‚ö†Ô∏è Index logic, break condition, best/average/worst case ‚Äì NOTHING is skipped.
‚ö†Ô∏è This lecture builds REAL understanding of Insertion Sort.

===============================================================================
0Ô∏è‚É£ LECTURE INTRODUCTION
===============================================================================

Hello Code Army, how are you all?

Today, we are starting our day with:
üëâ INSERTION SORT

We have already completed:
- Bubble Sort
- Selection Sort

And with this:
üëâ Our FOURTH WEEK of the 180 Days Challenge is completed üéâ

Without wasting any time, let‚Äôs start.

===============================================================================
1Ô∏è‚É£ REAL-LIFE STORY ‚Äì CARD GAME (JUHARI ANALOGY)
===============================================================================

Assume:
You are playing cards.

You and I both have cards:
7 4 2 3 5

Task:
Arrange cards in ASCENDING order.

How do we do it in real life?

----------------------------------------
STEP 1: FIRST CARD
----------------------------------------

First card = 7  
We place it in our hand.

Hand:
7

----------------------------------------
STEP 2: SECOND CARD (4)
----------------------------------------

Compare 4 with 7.

4 < 7  
So 4 should come BEFORE 7.

Hand becomes:
4 7

----------------------------------------
STEP 3: THIRD CARD (2)
----------------------------------------

Compare 2 with 7 ‚Üí smaller  
Compare 2 with 4 ‚Üí smaller  

So 2 goes at the FRONT.

Hand becomes:
2 4 7

----------------------------------------
STEP 4: FOURTH CARD (3)
----------------------------------------

Compare 3 with 7 ‚Üí smaller  
Compare 3 with 4 ‚Üí smaller  
Compare 3 with 2 ‚Üí bigger  

So 3 stays AFTER 2.

Hand becomes:
2 3 4 7

----------------------------------------
STEP 5: FIFTH CARD (5)
----------------------------------------

Compare 5 with 7 ‚Üí smaller  
Compare 5 with 4 ‚Üí bigger  

Stop here.

Final hand:
2 3 4 5 7

üí° This exact technique is called:
üëâ INSERTION SORT

===============================================================================
2Ô∏è‚É£ CORE IDEA OF INSERTION SORT
===============================================================================

Insertion Sort works on this idea:

üëâ Take one element at a time  
üëâ Insert it into its correct position  
üëâ Compare BACKWARDS  
üëâ Stop when correct position is found  

Just like inserting a card into a sorted hand.

===============================================================================
3Ô∏è‚É£ ARRAY VERSION OF THE SAME LOGIC
===============================================================================

Given array:
7 4 2 3 5

Important observation:
- First element is always considered SORTED
- We start from SECOND element

Why?
Because a single element is always sorted.

===============================================================================
4Ô∏è‚É£ ROUND 1 (i = 1 ‚Üí element = 4)
===============================================================================

Sorted part:
7

Compare:
4 < 7 ‚Üí swap

Array becomes:
4 7 2 3 5

Now index goes out of bound ‚Üí STOP.

Round 1 complete.
Sorted till index 1.

===============================================================================
5Ô∏è‚É£ ROUND 2 (i = 2 ‚Üí element = 2)
===============================================================================

Sorted part:
4 7

Compare:
2 < 7 ‚Üí swap
2 < 4 ‚Üí swap

Array becomes:
2 4 7 3 5

Now index < 0 ‚Üí STOP.

Sorted till index 2.

===============================================================================
6Ô∏è‚É£ ROUND 3 (i = 3 ‚Üí element = 3)
===============================================================================

Sorted part:
2 4 7

Compare:
3 < 7 ‚Üí swap
3 < 4 ‚Üí swap
3 > 2 ‚Üí STOP

Array becomes:
2 3 4 7 5

===============================================================================
7Ô∏è‚É£ ROUND 4 (i = 4 ‚Üí element = 5)
===============================================================================

Sorted part:
2 3 4 7

Compare:
5 < 7 ‚Üí swap
5 > 4 ‚Üí STOP

Final array:
2 3 4 5 7

===============================================================================
8Ô∏è‚É£ IMPORTANT OBSERVATION (VERY IMPORTANT)
===============================================================================

After every round:
- Left part becomes SORTED
- Only ONE element is inserted correctly

This repeats for every element.

===============================================================================
9Ô∏è‚É£ WHY COMPARISON GOES BACKWARDS
===============================================================================

Because:
- Left side is already sorted
- We only need to find correct position

Once we find a smaller element:
üëâ We STOP (break)

Because:
All elements before it are even smaller.

===============================================================================
üîü BASIC INSERTION SORT PATTERN
===============================================================================

Outer loop:
- Picks the element to insert

Inner loop:
- Moves backwards
- Compares with previous elements
- Swaps until correct position found

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ INSERTION SORT ALGORITHM
===============================================================================

For i = 1 to n-1:
    For j = i down to 1:
        If arr[j] < arr[j-1]:
            swap
        Else:
            break

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ C++ IMPLEMENTATION (INSERTION SORT)
===============================================================================

#include <iostream>
using namespace std;

int main()
{
    int arr[1000];
    int n;

    cout << "Enter size of array: ";
    cin >> n;

    cout << "Enter elements: ";
    for(int i = 0; i < n; i++)
        cin >> arr[i];

    for(int i = 1; i < n; i++)
    {
        for(int j = i; j > 0; j--)
        {
            if(arr[j] < arr[j - 1])
            {
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
            }
            else
            {
                break;
            }
        }
    }

    cout << "Sorted Array: ";
    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";

    return 0;
}

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ WHY BREAK IS NECESSARY
===============================================================================

If:
arr[j] > arr[j-1]

Then:
- Current element is already in correct position
- No need to check further

Without break:
‚ùå Unnecessary comparisons
‚ùå Slower performance

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ OUT-OF-BOUND PROTECTION
===============================================================================

Condition:
j > 0

Why?
Because:
arr[j-1] must exist.

Accessing invalid index:
‚ùå Segmentation fault
‚ùå Undefined behavior

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ TIME COMPLEXITY ANALYSIS
===============================================================================

----------------------------------------
WORST CASE
----------------------------------------
Reverse sorted array:
n(n-1)/2 comparisons

Time Complexity:
üëâ O(n¬≤)

----------------------------------------
BEST CASE
----------------------------------------
Already sorted array:
Only one comparison per element

Time Complexity:
üëâ O(n)

----------------------------------------
AVERAGE CASE
----------------------------------------
Random data

Time Complexity:
üëâ O(n¬≤)

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ SPACE COMPLEXITY
===============================================================================

Only constant variables used.

Auxiliary Space:
üëâ O(1)

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ GFG / ONLINE JUDGE IMPLEMENTATION
===============================================================================

GFG usually provides:
- Array
- Size
- Function to complete

Same logic is applied inside function.

If swap() is not allowed:
Use temp variable manually.

===============================================================================
1Ô∏è‚É£8Ô∏è‚É£ COMMON MISTAKE STUDENTS MAKE
===============================================================================

‚ùå Forgetting break
‚ùå Wrong loop condition
‚ùå Out-of-bound access
‚ùå Assuming forward comparison

Insertion Sort is ALWAYS backward comparison.

===============================================================================
1Ô∏è‚É£9Ô∏è‚É£ HOMEWORK (VERY IMPORTANT)
===============================================================================

1Ô∏è‚É£ Insertion Sort in DESCENDING order  
2Ô∏è‚É£ Insertion Sort starting from BACK side  
3Ô∏è‚É£ Insert only LAST element into sorted array  

Practice these to MASTER loops.

===============================================================================
üéØ FINAL TAKEAWAY
===============================================================================

Insertion Sort:
- Mimics real-life card sorting
- Very efficient for nearly sorted arrays
- Builds strong loop intuition
- Used in real systems for small datasets

If this made sense:
üëâ You are learning REAL DSA.

JAI HIND üáÆüá≥  
JAI BHARAT üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
