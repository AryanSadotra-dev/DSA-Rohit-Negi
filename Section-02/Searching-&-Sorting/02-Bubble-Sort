/*
===============================================================================
üìò DSA LECTURE NOTES ‚Äì DAY 23
BUBBLE SORT
(DSA ‚Äì 180 Days Coding Challenge)
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready)
===============================================================================

‚ö†Ô∏è These notes are NOT a definition dump.
‚ö†Ô∏è These notes reconstruct the teacher‚Äôs exact thinking process.
‚ö†Ô∏è Stories, repetition, pattern-building are INTENTIONAL.
‚ö†Ô∏è Index logic, loop boundaries, optimization ‚Äì NOTHING is skipped.
‚ö†Ô∏è This lecture builds STRONG loop + array fundamentals.

===============================================================================
0Ô∏è‚É£ LECTURE INTRODUCTION
===============================================================================

Hello Gadar Army, how are you all?

I hope you all are doing great in your lives and learning with full energy.

Yesterday, we studied:
üëâ What sorting is
üëâ Why sorting is needed
üëâ Selection Sort

We learned:
- Bring the SMALLEST element to the FRONT
- Fix position one by one

Today, we will study another sorting algorithm:
üëâ BUBBLE SORT

This time:
- We will push the LARGEST element to the BACK

===============================================================================
1Ô∏è‚É£ RECAP ‚Äì WHAT IS SORTING?
===============================================================================

Sorting means arranging elements in a proper order.

Example:
7 4 8 5 3

Ascending Order:
3 4 5 7 8

Descending Order:
8 7 5 4 3

This arranging process is called SORTING.

===============================================================================
2Ô∏è‚É£ REAL-LIFE STORY ‚Äì SCHOOL ASSEMBLY
===============================================================================

Imagine a school assembly.

Students are standing with heights:
7 4 8 5 3

Goal:
Arrange them in INCREASING order.

Yesterday (Selection Sort):
- Find smallest
- Bring it to the front

Today (Bubble Sort):
- Compare neighbors
- Push bigger ones to the back

===============================================================================
3Ô∏è‚É£ CORE IDEA OF BUBBLE SORT
===============================================================================

Bubble Sort idea is very simple:

üëâ Compare ADJACENT elements
üëâ If left is bigger, SWAP
üëâ Bigger elements move towards the END

Just like bubbles:
- Small bubbles stay down
- Big bubbles rise up

That‚Äôs why the name:
üëâ BUBBLE SORT

===============================================================================
4Ô∏è‚É£ FIRST COMPLETE DRY RUN (DETAILED)
===============================================================================

Initial array:
7 4 8 5 3

Index:
0 1 2 3 4

----------------------------------------
ROUND 1 START
----------------------------------------

Compare arr[0] & arr[1]:
7 > 4 ‚Üí swap
4 7 8 5 3

Compare arr[1] & arr[2]:
7 < 8 ‚Üí no swap
4 7 8 5 3

Compare arr[2] & arr[3]:
8 > 5 ‚Üí swap
4 7 5 8 3

Compare arr[3] & arr[4]:
8 > 3 ‚Üí swap
4 7 5 3 8

üî¥ Observation:
Largest element (8) reached LAST index.

----------------------------------------
ROUND 1 COMPLETE
----------------------------------------

===============================================================================
5Ô∏è‚É£ WHY ROUND 1 STOPS AT INDEX 3
===============================================================================

We compared:
(0,1), (1,2), (2,3), (3,4)

Why NOT (4,5)?
Because index 5 DOES NOT EXIST.

If size = n:
Last valid index = n - 1

So comparisons go till:
j <= n - 2

Because:
arr[j+1] must be valid.

===============================================================================
6Ô∏è‚É£ ROUND 2 (DETAILED)
===============================================================================

Now we KNOW:
- Last element is sorted
- No need to touch it again

Array:
4 7 5 3 | 8

Comparisons:

(0,1): 4 < 7 ‚Üí no swap
(1,2): 7 > 5 ‚Üí swap
4 5 7 3 8

(2,3): 7 > 3 ‚Üí swap
4 5 3 7 8

üî¥ Now:
Second largest element (7) fixed.

===============================================================================
7Ô∏è‚É£ ROUND 3
===============================================================================

Array:
4 5 3 | 7 8

(0,1): 4 < 5 ‚Üí no swap
(1,2): 5 > 3 ‚Üí swap
4 3 5 7 8

===============================================================================
8Ô∏è‚É£ ROUND 4
===============================================================================

Array:
4 3 | 5 7 8

(0,1): 4 > 3 ‚Üí swap
3 4 5 7 8

Array sorted.

===============================================================================
9Ô∏è‚É£ NUMBER OF ROUNDS (VERY IMPORTANT)
===============================================================================

If array size = n

Total rounds = n - 1

Why?
If n-1 largest elements are placed correctly,
the smallest automatically comes first.

===============================================================================
üîü PATTERN DERIVATION (CRITICAL PART)
===============================================================================

Indexes compared in each round:

Round 1: j = 0 ‚Üí 3
Round 2: j = 0 ‚Üí 2
Round 3: j = 0 ‚Üí 1
Round 4: j = 0 ‚Üí 0

Pattern:
0‚Üí3
0‚Üí2
0‚Üí1
0‚Üí0

Left side is CONSTANT (0)
Right side is DECREASING

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ HOW TO CONVERT PATTERN INTO CODE
===============================================================================

Right boundary values:
3, 2, 1, 0

If size = 5:
n - 2 = 3

So outer loop:
i = n - 2 ‚Üí 0

Inner loop:
j = 0 ‚Üí i

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ BASIC BUBBLE SORT ALGORITHM
===============================================================================

for i = n-2 down to 0:
    for j = 0 to i:
        if arr[j] > arr[j+1]:
            swap

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ C++ IMPLEMENTATION (BASIC)
===============================================================================

#include <iostream>
using namespace std;

int main()
{
    int arr[1000];
    int n;

    cout << "Enter size of array: ";
    cin >> n;

    cout << "Enter elements: ";
    for(int i = 0; i < n; i++)
        cin >> arr[i];

    for(int i = n - 2; i >= 0; i--)
    {
        for(int j = 0; j <= i; j++)
        {
            if(arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    cout << "Sorted Array: ";
    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";

    return 0;
}

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ SINGLE-PASS PROBLEM (IMPORTANT CONCEPT)
===============================================================================

Problem:
Push ONLY the largest element to the end (one pass).

Logic:
Run inner loop ONCE:
j = 0 ‚Üí n-2

This idea builds Bubble Sort.

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ WHY BASIC BUBBLE SORT IS NOT OPTIMAL
===============================================================================

Even if array is already sorted:
- Algorithm still runs all rounds
- Waste of comparisons

We can OPTIMIZE.

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ OPTIMIZED BUBBLE SORT (BEST CASE)
===============================================================================

Idea:
If in one full pass:
NO SWAP happens

Then:
Array is already sorted.

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ OPTIMIZED C++ CODE
===============================================================================

#include <iostream>
using namespace std;

int main()
{
    int arr[1000];
    int n;

    cout << "Enter size of array: ";
    cin >> n;

    cout << "Enter elements: ";
    for(int i = 0; i < n; i++)
        cin >> arr[i];

    for(int i = n - 2; i >= 0; i--)
    {
        bool swapped = false;

        for(int j = 0; j <= i; j++)
        {
            if(arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }

        if(swapped == false)
            break;
    }

    cout << "Sorted Array: ";
    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";

    return 0;
}

===============================================================================
1Ô∏è‚É£8Ô∏è‚É£ TIME COMPLEXITY ANALYSIS
===============================================================================

Worst Case:
Reverse sorted array
O(n¬≤)

Average Case:
Random array
O(n¬≤)

Best Case (Optimized):
Already sorted array
O(n)

===============================================================================
1Ô∏è‚É£9Ô∏è‚É£ SPACE COMPLEXITY
===============================================================================

Only constant extra variables used.

Space Complexity:
üëâ O(1)

===============================================================================
2Ô∏è‚É£0Ô∏è‚É£ GFG / INTERVIEW MAPPING
===============================================================================

- Same logic works inside function
- Same loops
- Same swap condition
- Expected complexity: O(n¬≤)

===============================================================================
2Ô∏è‚É£1Ô∏è‚É£ HOMEWORK
===============================================================================

1Ô∏è‚É£ Bubble Sort in DESCENDING order  
2Ô∏è‚É£ Bubble Sort starting from BACK side  
3Ô∏è‚É£ Bubble Sort on character array  

If you can do these:
üëâ You have MASTERED loops.

===============================================================================
üéØ FINAL TAKEAWAY
===============================================================================

Bubble Sort:
- Compares adjacent elements
- Pushes largest elements to the back
- Builds loop intuition
- Teaches optimization thinking

This is NOT about speed.
This is about THINKING.

JAI HIND üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
