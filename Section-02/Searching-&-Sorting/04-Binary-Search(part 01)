/*
===============================================================================
üìò DSA LECTURE NOTES ‚Äì DAY XX
BINARY SEARCH
(Complete Classroom Teaching ‚Äì Full Reconstruction)
(Language: Teacher-style English with Hinglish Flow)
===============================================================================

‚ö†Ô∏è These notes are a DIRECT reconstruction of the lecture.
‚ö†Ô∏è Real-life analogies, repetition, doubts, mistakes & fixes are INTENTIONAL.
‚ö†Ô∏è Interview-oriented thinking is preserved.
‚ö†Ô∏è Nothing is skipped.

===============================================================================
0Ô∏è‚É£ INTRODUCTION ‚Äì WHY THIS TOPIC MATTERS
===============================================================================

Hello Coder Army, kaise hain aap sab log?

I think aap sab apni life mein macha rahe honge üî•

Today, we are going to study a VERY IMPORTANT topic:
üëâ BINARY SEARCH

This question was asked to me directly in interview rounds.
Big companies ask this topic again and again.

Problem is NOT that binary search is hard.
Problem is:
‚ùå Students fail to IDENTIFY that a problem is a Binary Search problem.

After this Binary Search series:
üëâ You will INSTANTLY catch that this is a Binary Search problem.

===============================================================================
1Ô∏è‚É£ WHAT SEARCHING TECHNIQUE WE KNOW ALREADY
===============================================================================

Till now, we have studied:
üëâ LINEAR SEARCH

Example:
Array = [1, 3, 5, 7, 9]

If I want to find 1:
- Check index 0
- Then index 1
- Then index 2
- Continue‚Ä¶

Time Complexity:
üëâ O(n)

This is BRUTE FORCE.

===============================================================================
2Ô∏è‚É£ WHEN BINARY SEARCH CAN BE APPLIED (VERY IMPORTANT)
===============================================================================

Binary Search can ONLY be applied when:
‚úÖ Data is SORTED

Sorted can be:
- Increasing order
- Decreasing order

That is why before search:
üëâ We studied Sorting (Bubble, Selection, Insertion)

If data is NOT sorted:
‚ùå Binary Search CANNOT be applied.

===============================================================================
3Ô∏è‚É£ REAL LIFE ANALOGY ‚Äì DICTIONARY üìñ
===============================================================================

Think of a dictionary.

You want to find meaning of word:
üëâ ‚ÄúDevelopment‚Äù

What do you do?
- Open dictionary from the MIDDLE
- Suppose page shows word starting with ‚ÄòP‚Äô

Now you know:
üëâ ‚ÄúDevelopment‚Äù comes BEFORE ‚ÄòP‚Äô

So you IGNORE right half.
Then again:
- Open left half from middle
- Check first letter
- Decide direction

You NEVER search word by word.

That is:
üëâ BINARY SEARCH

===============================================================================
4Ô∏è‚É£ CORE IDEA OF BINARY SEARCH
===============================================================================

Binary Search works by:
- Dividing search space into HALF
- Ignoring one half every step

This makes it VERY FAST.

===============================================================================
5Ô∏è‚É£ SIMPLE ARRAY EXAMPLE
===============================================================================

Sorted Array:
[3, 6, 10, 11]

Find: 10

Step 1:
Middle element = 6
10 > 6 ‚Üí Search RIGHT

Step 2:
Array left = [10, 11]
Middle = 10

FOUND.

===============================================================================
6Ô∏è‚É£ HOW TO FIND MIDDLE ELEMENT (INDEX LOGIC)
===============================================================================

Indexes:
0 1 2 3 4

Middle index:
(mid) = (start + end) / 2

Example:
start = 0
end = 4

mid = (0 + 4) / 2 = 2

===============================================================================
7Ô∏è‚É£ DETAILED EXAMPLE (IMPORTANT)
===============================================================================

Array:
[3, 7, 11, 12, 17, 18, 23, 27, 29]

Find: 27

start = 0, end = 8
mid = (0 + 8)/2 = 4 ‚Üí arr[4] = 17

27 > 17 ‚Üí RIGHT side

start = 5, end = 8
mid = (5 + 8)/2 = 6 ‚Üí arr[6] = 23

27 > 23 ‚Üí RIGHT side

start = 7, end = 8
mid = (7 + 8)/2 = 7 ‚Üí arr[7] = 27

FOUND.

===============================================================================
8Ô∏è‚É£ WHY IT IS FAST
===============================================================================

Linear Search:
Up to n steps.

Binary Search:
Every step removes HALF array.

Example:
100 ‚Üí 50 ‚Üí 25 ‚Üí 12 ‚Üí 6 ‚Üí 3 ‚Üí 1

Huge difference.

===============================================================================
9Ô∏è‚É£ BASIC CONDITIONS IN BINARY SEARCH
===============================================================================

At every step:

1Ô∏è‚É£ If arr[mid] == key
   ‚Üí FOUND

2Ô∏è‚É£ If arr[mid] < key
   ‚Üí Search RIGHT
   ‚Üí start = mid + 1

3Ô∏è‚É£ Else
   ‚Üí Search LEFT
   ‚Üí end = mid - 1

===============================================================================
üîü LOOP TERMINATION CONDITION
===============================================================================

When element is NOT present.

We stop when:
üëâ start > end

Loop condition:
while(start <= end)

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ BASIC BINARY SEARCH CODE (C++)
===============================================================================

int binarySearch(int arr[], int n, int key)
{
    int start = 0;
    int end = n - 1;

    while(start <= end)
    {
        int mid = (start + end) / 2;

        if(arr[mid] == key)
            return mid;
        else if(arr[mid] < key)
            start = mid + 1;
        else
            end = mid - 1;
    }
    return -1;
}

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ INTEGER OVERFLOW PROBLEM (VERY IMPORTANT)
===============================================================================

Problem:
mid = (start + end) / 2

If start and end are very large:
‚Üí INTEGER OVERFLOW

Example:
INT max = 2¬≥¬π - 1

start + end may exceed limit.

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ SAFE WAY TO CALCULATE MID
===============================================================================

Correct formula:
mid = start + (end - start) / 2;

Why safe?
- (end - start) is small
- No overflow possible

ALWAYS use this in interviews.

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ COMPLETE SAFE BINARY SEARCH CODE
===============================================================================

int binarySearch(int arr[], int n, int key)
{
    int start = 0;
    int end = n - 1;

    while(start <= end)
    {
        int mid = start + (end - start) / 2;

        if(arr[mid] == key)
            return mid;
        else if(arr[mid] < key)
            start = mid + 1;
        else
            end = mid - 1;
    }
    return -1;
}

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ TIME COMPLEXITY ANALYSIS
===============================================================================

Worst Case:
Array size keeps halving until 1.

n = 2·µè
k = log‚ÇÇ n

üëâ Time Complexity = O(log n)

Best Case:
Element found at first mid.

üëâ O(1)

Average Case:
üëâ O(log n)

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ SPACE COMPLEXITY
===============================================================================

Only variables used.

Auxiliary Space:
üëâ O(1)

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ WHEN ELEMENT IS NOT PRESENT
===============================================================================

Example:
[2, 4, 6, 10, 12]
Find: 11

Eventually:
start > end

Loop stops.
Return -1.

===============================================================================
1Ô∏è‚É£8Ô∏è‚É£ INTERVIEW TIP ‚Äì IDENTIFY BINARY SEARCH
===============================================================================

Binary Search hints:
- Sorted array
- Find minimum / maximum
- First / last occurrence
- Answer lies in range
- ‚ÄúMinimize‚Äù or ‚Äúmaximize‚Äù problems

===============================================================================
1Ô∏è‚É£9Ô∏è‚É£ HOMEWORK
===============================================================================

1Ô∏è‚É£ Binary Search on DECREASING array  
2Ô∏è‚É£ Find first & last occurrence  
3Ô∏è‚É£ Binary Search on answer (future topic)

===============================================================================
üéØ FINAL TAKEAWAY
===============================================================================

Binary Search:
- Is NOT just a search
- Is a THINKING PATTERN
- Foundation of many advanced problems

If this is clear:
üëâ You are interview ready for search problems.

JAI HIND üáÆüá≥  
JAI BHARAT üáÆüá≥

===============================================================================
END OF FILE
===============================================================================
*/
