/*
===============================================================================
üìò DSA LECTURE NOTES
TOPIC: BINARY SEARCH IN 2D ARRAYS
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready ‚Äì Single File)
===============================================================================

‚ö†Ô∏è This is a DIRECT reconstruction of the lecture.
‚ö†Ô∏è Nothing is summarized or skipped.
‚ö†Ô∏è Thinking process is preserved exactly as taught.
‚ö†Ô∏è Language converted from Hinglish ‚Üí Clear English.
‚ö†Ô∏è Code language: C++.

===============================================================================
0Ô∏è‚É£ INTRODUCTION
===============================================================================

Hello Code Army, how are you all?
I hope everyone is doing well.

Today we are going to solve TWO very important problems:

1Ô∏è‚É£ Binary Search in a 2D Matrix (fully sorted matrix)
2Ô∏è‚É£ Search in a Row-wise & Column-wise Sorted Matrix

These problems look similar, but the APPROACH is COMPLETELY DIFFERENT.

===============================================================================
1Ô∏è‚É£ WHEN CAN WE APPLY BINARY SEARCH?
===============================================================================

Binary Search can ONLY be applied when:
‚úî Data is sorted (increasing or decreasing)

If data is unsorted ‚Üí Binary Search ‚ùå

So first question in every problem:
üëâ Is the data sorted or not?

===============================================================================
2Ô∏è‚É£ PROBLEM 1: SEARCH IN A FULLY SORTED 2D MATRIX
===============================================================================

You are given a 2D matrix:
- Rows = n
- Columns = m
- Entire matrix is sorted in increasing order

Example (4 √ó 5):

2   6   10  14  18
20  24  27  29  38
47  52  78  93  102
108 111 200 218 320

Target = 52

Property:
‚úî Each row is sorted
‚úî Last element of previous row < first element of next row
‚úî Entire matrix behaves like ONE SORTED ARRAY

===============================================================================
3Ô∏è‚É£ BRUTE FORCE APPROACH
===============================================================================

Idea:
- Traverse every element
- Compare with target

Code logic:
for each row
  for each column
    if element == target ‚Üí return true

Time Complexity: O(n √ó m)
Space Complexity: O(1)

This works, but it is SLOW.

===============================================================================
4Ô∏è‚É£ BETTER APPROACH (ROW SELECTION + BINARY SEARCH)
===============================================================================

Observation:
Each row is sorted.

Idea:
1. Find the row where target CAN exist
2. Apply Binary Search on that row

How to check row?
Target must satisfy:
matrix[row][0] <= target <= matrix[row][m-1]

Once row is found:
‚úî Apply Binary Search on columns

Worst Case:
- Row scanning ‚Üí O(n)
- Binary search ‚Üí O(log m)

Time Complexity: O(n + log m)
Space Complexity: O(1)

Better, but still NOT optimal.

===============================================================================
5Ô∏è‚É£ OPTIMAL APPROACH (MOST IMPORTANT)
===============================================================================

Key Observation:
The entire matrix is SORTED as if it is a 1D array.

Total elements = n √ó m

We will:
‚úî APPLY BINARY SEARCH DIRECTLY
‚úî WITHOUT creating a 1D array

We only SIMULATE a 1D array.

===============================================================================
6Ô∏è‚É£ 2D ‚Üí 1D MAPPING (ROW MAJOR ORDER)
===============================================================================

For any index `mid` in imaginary 1D array:

rowIndex = mid / m
colIndex = mid % m

This formula comes from ROW MAJOR ORDER.

===============================================================================
7Ô∏è‚É£ BINARY SEARCH LOGIC
===============================================================================

start = 0
end = (n √ó m) - 1

While start <= end:
- mid = start + (end - start) / 2
- Convert mid ‚Üí (row, col)
- Compare matrix[row][col] with target

If equal ‚Üí FOUND
If smaller ‚Üí search right
If larger ‚Üí search left

===============================================================================
8Ô∏è‚É£ FINAL CODE (PROBLEM 1)
===============================================================================

bool searchMatrix(vector<vector<int>>& matrix, int target)
{
    int n = matrix.size();
    int m = matrix[0].size();

    int start = 0;
    int end = (n * m) - 1;

    while (start <= end)
    {
        int mid = start + (end - start) / 2;

        int row = mid / m;
        int col = mid % m;

        if (matrix[row][col] == target)
            return true;
        else if (matrix[row][col] < target)
            start = mid + 1;
        else
            end = mid - 1;
    }
    return false;
}

Time Complexity: O(log (n √ó m))
Space Complexity: O(1)

===============================================================================
9Ô∏è‚É£ PROBLEM 2: SEARCH IN ROW-WISE & COLUMN-WISE SORTED MATRIX
===============================================================================

Matrix properties:
‚úî Every row is sorted
‚úî Every column is sorted
‚ùå Entire matrix is NOT fully sorted

Example:

10  20  30  40
15  25  35  45
27  29  37  48
32  33  39  50

Target = 50

Binary Search directly ‚ùå (matrix not fully sorted)

===============================================================================
üîü BRUTE FORCE APPROACH
===============================================================================

Check every element.

Time Complexity: O(n √ó m)
Space Complexity: O(1)

But we can do MUCH better.

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ OPTIMAL APPROACH (STAIRCASE SEARCH)
===============================================================================

Key Idea:
Start from TOP-RIGHT corner.

Why?
- Left ‚Üí values decrease
- Down ‚Üí values increase

This gives clear decision-making.

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ DECISION RULES
===============================================================================

Let current element = matrix[i][j]

If matrix[i][j] == target:
    FOUND

If matrix[i][j] < target:
    Move DOWN (i++)

If matrix[i][j] > target:
    Move LEFT (j--)

Only TWO moves possible ‚Üí clean elimination.

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ LOOP CONDITIONS
===============================================================================

Start:
i = 0
j = m - 1

Loop until:
i < n AND j >= 0

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ FINAL CODE (PROBLEM 2)
===============================================================================

bool searchRowColSortedMatrix(vector<vector<int>>& matrix, int target)
{
    int n = matrix.size();
    int m = matrix[0].size();

    int i = 0;
    int j = m - 1;

    while (i < n && j >= 0)
    {
        if (matrix[i][j] == target)
            return true;
        else if (matrix[i][j] < target)
            i++;        // move down
        else
            j--;        // move left
    }
    return false;
}

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ TIME & SPACE COMPLEXITY (PROBLEM 2)
===============================================================================

Worst Case:
- Moves at most n steps down
- Moves at most m steps left

Time Complexity: O(n + m)
Space Complexity: O(1)

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ WHY CORNERS MATTER
===============================================================================

Valid starting corners:
‚úî Top-right
‚úî Bottom-left

Invalid corners:
‚ùå Top-left (both directions increase)
‚ùå Bottom-right (both directions decrease)

We need ONE increasing & ONE decreasing direction.

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ KEY TAKEAWAYS
===============================================================================

‚úî Always check SORTING PROPERTY
‚úî Fully sorted matrix ‚Üí Binary Search on n*m
‚úî Row & column sorted ‚Üí Staircase search
‚úî Never force Binary Search blindly
‚úî Index mapping is the HEART of 2D binary search

===============================================================================
üéØ FINAL MESSAGE FROM TEACHER
===============================================================================

If you master these two problems:
- 90% of 2D Binary Search questions are DONE
- Interviews become EASY
- Logic becomes sharp

Homework:
- Binary search in decreasing order array
- Practice both problems again without seeing code

JAI HIND üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
