/*
===============================================================================
üìò DSA LECTURE NOTES ‚Äì PART 2
2D ARRAYS (COLUMN MAJOR, 2D VECTORS, WAVE, SPIRAL, TRANSPOSE)
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready ‚Äì Single File)
===============================================================================

‚ö†Ô∏è This is NOT a summary.
‚ö†Ô∏è This is a full reconstruction of the teacher‚Äôs lecture.
‚ö†Ô∏è All logic, examples, jokes, and edge-case reasoning are preserved.
‚ö†Ô∏è Language converted from Hinglish ‚Üí Clear English.
‚ö†Ô∏è Code language: C++

===============================================================================
0Ô∏è‚É£ LECTURE INTRODUCTION
===============================================================================

Hello Code Army, how are you all?

I hope everyone is doing well.

Yesterday we studied:
‚úî Row Major Order
‚úî Memory layout of 2D arrays
‚úî Index calculation

Today we will study:
üëâ COLUMN MAJOR ORDER
üëâ WHY systems choose row or column major
üëâ REAL LIFE DATABASE EXAMPLES
üëâ 2D VECTORS
üëâ IMPORTANT MATRIX PROBLEMS

This is the SECOND PART of 2D Arrays.

===============================================================================
1Ô∏è‚É£ COLUMN MAJOR ORDER
===============================================================================

In column major order:
- Data is stored COLUMN by COLUMN
- First complete column is stored
- Then second column
- Then third column

Example matrix (4 √ó 3):

1   2   3
4   5   6
7   8   9
10 11  12

Column Major storage order:

1, 4, 7, 10,
2, 5, 8, 11,
3, 6, 9, 12

Difference:
- Row Major ‚Üí Row-wise storage
- Column Major ‚Üí Column-wise storage

===============================================================================
2Ô∏è‚É£ FIND INDEX IN COLUMN MAJOR ORDER
===============================================================================

Given:
- arr[i][j]
- Rows = R
- Columns = C

Column Major index formula:

index = (j * R) + i

Homework given in lecture:
üëâ Derive this formula yourself (same logic as row major)

===============================================================================
3Ô∏è‚É£ WHICH LANGUAGES FOLLOW WHAT?
===============================================================================

C / C++ / Java:
‚úî Follow ROW MAJOR ORDER by default

Fortran:
‚úî Follows COLUMN MAJOR ORDER

Reason:
- Faster address calculation
- Compiler simplicity
- Cache friendliness

===============================================================================
4Ô∏è‚É£ REAL WORLD DATABASE EXAMPLE (VERY IMPORTANT)
===============================================================================

Consider a banking system:

Each user has:
- ID
- Account Number
- Balance

Tabular data:

ID   Account   Balance
1    12        100
2    23        200
3    46        300
4    72        100
5    85        500

This is clearly a 2D structure.

Memory CANNOT store 2D directly.
Internally, it MUST be stored as 1D contiguous memory.

Now decision:
- Store row-wise OR column-wise?

===============================================================================
5Ô∏è‚É£ WHY COLUMN MAJOR CAN BE BETTER (SUM EXAMPLE)
===============================================================================

If bank owner wants:
üëâ TOTAL MONEY in bank

Column Major stores balances CONTIGUOUSLY.

So summing balances is:
- Sequential access
- Cache friendly
- Faster

Row Major would require:
- Jumping memory locations
- Slower summation

===============================================================================
6Ô∏è‚É£ WHY ROW MAJOR IS BETTER (LOGIN SYSTEM)
===============================================================================

Login system:
- Email
- Phone
- Password

You NEVER do mathematical operations.
You just MATCH row-wise data.

So row-major is better:
- One user = one row
- Easy comparison
- Minimal jumps

üëâ Conclusion:
Choice depends on REQUIREMENT.

===============================================================================
7Ô∏è‚É£ WHY 2D ARRAYS ARE STORED AS 1D IN MEMORY
===============================================================================

Arrays must be:
‚úî Contiguous
‚úî Predictable address calculation

If 2D were stored randomly:
- Address of next element unknown
- Formula fails
- CPU becomes slow

Hence:
üëâ 2D arrays are flattened internally

===============================================================================
8Ô∏è‚É£ INTRODUCTION TO 2D VECTOR
===============================================================================

2D Vector = Vector of vectors

Syntax:

vector<vector<int>> matrix;

This is dynamic:
- Rows can change
- Columns can change
- Safer than arrays

===============================================================================
9Ô∏è‚É£ CREATING 2D VECTOR
===============================================================================

vector<vector<int>> matrix(rows, vector<int>(cols, value));

Example:

vector<vector<int>> matrix(3, vector<int>(4, 2));

Means:
- 3 rows
- 4 columns
- All values = 2

===============================================================================
üîü ACCESS & UPDATE
===============================================================================

matrix[0][2] = 5;

Input:

cin >> matrix[i][j];

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ FIND ROWS & COLUMNS IN 2D VECTOR
===============================================================================

Rows:
matrix.size()

Columns:
matrix[0].size()

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ WAVE PRINT (COLUMN WISE)
===============================================================================

Problem:
Print matrix in wave form column-wise.

Logic:
- Traverse column by column
- If column index is EVEN ‚Üí top to bottom
- If column index is ODD ‚Üí bottom to top

Code Logic:

for (int j = 0; j < cols; j++)
{
    if (j % 2 == 0)
    {
        for (int i = 0; i < rows; i++)
            print(arr[i][j]);
    }
    else
    {
        for (int i = rows - 1; i >= 0; i--)
            print(arr[i][j]);
    }
}

Time Complexity: O(rows √ó cols)
Space Complexity: O(1)

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ SPIRAL MATRIX (CORE INTERVIEW PROBLEM)
===============================================================================

Approach:
Maintain four boundaries:
- top
- bottom
- left
- right

Process order:
1. Print top row
2. Print right column
3. Print bottom row
4. Print left column

After each step, shrink boundary.

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ STOP CONDITIONS (EDGE CASES)
===============================================================================

Must check:
- top <= bottom
- left <= right

Otherwise:
‚ùå Duplicate prints
‚ùå Wrong answers

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ SPIRAL MATRIX CODE LOGIC (VECTOR OUTPUT)
===============================================================================

while (top <= bottom && left <= right)
{
    // Top row
    for (j = left; j <= right; j++)
        ans.push_back(matrix[top][j]);
    top++;

    // Right column
    for (i = top; i <= bottom; i++)
        ans.push_back(matrix[i][right]);
    right--;

    // Bottom row
    if (top <= bottom)
    {
        for (j = right; j >= left; j--)
            ans.push_back(matrix[bottom][j]);
        bottom--;
    }

    // Left column
    if (left <= right)
    {
        for (i = bottom; i >= top; i--)
            ans.push_back(matrix[i][left]);
        left++;
    }
}

Time Complexity: O(rows √ó cols)
Space Complexity: O(rows √ó cols)

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ TRANSPOSE OF MATRIX
===============================================================================

Transpose means:
- Convert rows into columns
- Convert columns into rows

Only possible directly for:
‚úî Square Matrix (n √ó n)

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ TRANSPOSE USING EXTRA MATRIX
===============================================================================

new[j][i] = matrix[i][j];

Time Complexity: O(n¬≤)
Space Complexity: O(n¬≤)

===============================================================================
1Ô∏è‚É£8Ô∏è‚É£ IN-PLACE TRANSPOSE (IMPORTANT)
===============================================================================

Key observation:
- Diagonal elements stay same
- Swap only upper triangle with lower triangle

Code:

for (int i = 0; i < n; i++)
{
    for (int j = i + 1; j < n; j++)
    {
        swap(matrix[i][j], matrix[j][i]);
    }
}

Why j = i + 1?
‚úî Prevent double swapping
‚úî Avoid reverting changes

Time Complexity: O(n¬≤)
Space Complexity: O(1)

===============================================================================
üéØ FINAL TAKEAWAYS
===============================================================================

‚úî Column Major vs Row Major fully understood
‚úî Real-world database reasoning
‚úî 2D Vector creation & usage
‚úî Wave print logic
‚úî Spiral matrix with edge cases
‚úî Transpose (extra + in-place)
‚úî Interview-level thinking achieved

This lecture was HEAVY ‚Äî but foundational.

JAI HIND üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
