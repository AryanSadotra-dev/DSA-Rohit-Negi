/*
===============================================================================
üìò DSA LECTURE NOTES
TOPIC: 2D ARRAYS (Two Dimensional Arrays)
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready ‚Äì Single File)
===============================================================================

‚ö†Ô∏è These notes are NOT summarized.
‚ö†Ô∏è These notes reconstruct the teacher‚Äôs complete explanation.
‚ö†Ô∏è Concepts are explained from ZERO ‚Üí DSA LEVEL.
‚ö†Ô∏è Hinglish tone converted to clear English teaching style.

===============================================================================
0Ô∏è‚É£ LECTURE INTRODUCTION
===============================================================================

Hello Code Army, how are you all?

I hope everyone is doing well.

Today we are going to discuss a VERY IMPORTANT topic:
üëâ TWO DIMENSIONAL ARRAYS (2D ARRAYS)

We will understand:
‚úî What is a 2D array
‚úî Why we needed it
‚úî Which problem it solves
‚úî How it is stored in memory
‚úî How indexing works
‚úî How computers access elements
‚úî Real-life use cases
‚úî Practical coding problems

So let‚Äôs begin.

===============================================================================
1Ô∏è‚É£ REAL LIFE PROBLEM ‚Äì EXCEL SHEET
===============================================================================

All of you have used an Excel sheet.

In an Excel sheet:
- There are rows
- There are columns
- Each cell stores some data

Example:
- Column 1 ‚Üí Phone Number
- Column 2 ‚Üí Age
- Column 3 ‚Üí Bank Account Number

The data looks like this:

Row 0:  Phone   Age   Account
Row 1:  9823   24    7395
Row 2:  9811   20    3272
Row 3:  9917   32    7392

This is TABULAR DATA.

Now the question is:
üëâ How do we store this type of data inside a computer program?

===============================================================================
2Ô∏è‚É£ WHY 1D ARRAY IS NOT ENOUGH
===============================================================================

You may think:
"Let me create one 1D array for each row."

That means:
- arr1[3]
- arr2[3]
- arr3[3]
- arr4[3]

This works for 4 rows.

But now imagine:
‚ùå 100 rows
‚ùå 1,000 rows
‚ùå 1,00,000 rows

Will you create:
arr1, arr2, arr3, ..., arr100000 ?

‚ùå Impossible
‚ùå Too much code
‚ùå Not scalable
‚ùå Not practical

So we need a BETTER solution.

===============================================================================
3Ô∏è‚É£ SOLUTION ‚Äì TWO DIMENSIONAL ARRAY
===============================================================================

A 2D array allows us to store:
- Rows
- Columns
- Tabular data

Definition:
A 2D array is an array of arrays.

One dimension ‚Üí rows  
Second dimension ‚Üí columns  

Example:
4 rows √ó 3 columns

===============================================================================
4Ô∏è‚É£ VISUAL REPRESENTATION OF 2D ARRAY
===============================================================================

Indexing:

Rows:    0   1   2   3
Columns: 0   1   2

Element naming:
arr[0][0], arr[0][1], arr[0][2]
arr[1][0], arr[1][1], arr[1][2]
arr[2][0], arr[2][1], arr[2][2]
arr[3][0], arr[3][1], arr[3][2]

Each element is identified by:
[row_index][column_index]

===============================================================================
5Ô∏è‚É£ REAL LIFE EXAMPLES OF 2D ARRAYS
===============================================================================

‚úî Excel Sheet
‚úî Chess Board (8 √ó 8)
‚úî Tic Tac Toe (3 √ó 3)
‚úî Matrix operations
‚úî Image pixels
‚úî Game boards

===============================================================================
6Ô∏è‚É£ MEMORY ALLOCATION OF 2D ARRAYS
===============================================================================

Important concept:
‚ùó Even though 2D array looks like a grid,
‚ùó In memory it is stored LINEARLY.

Arrays are stored in:
üëâ CONTIGUOUS MEMORY LOCATIONS

There are two storage methods:
1Ô∏è‚É£ Row Major Order (used in C/C++)
2Ô∏è‚É£ Column Major Order (used in Fortran)

We focus on:
üëâ ROW MAJOR ORDER

===============================================================================
7Ô∏è‚É£ ROW MAJOR ORDER (VERY IMPORTANT)
===============================================================================

Row major means:
- First complete row 0 is stored
- Then row 1
- Then row 2
- And so on

Example (4 √ó 3):

Row 0 ‚Üí [0][0] [0][1] [0][2]
Row 1 ‚Üí [1][0] [1][1] [1][2]
Row 2 ‚Üí [2][0] [2][1] [2][2]
Row 3 ‚Üí [3][0] [3][1] [3][2]

Memory layout (as 1D array):

Index:  0  1  2  3  4  5  6  7  8  9  10 11
Data : 00 01 02 10 11 12 20 21 22 30 31 32

So internally:
üëâ 2D array behaves like a 1D array

===============================================================================
8Ô∏è‚É£ FORMULA: 2D ‚Üí 1D INDEX CONVERSION
===============================================================================

If:
- Columns = C
- Element = arr[i][j]

Then its linear index is:

index = (i √ó C) + j

Example:
arr[2][1], C = 3

index = (2 √ó 3) + 1 = 7

===============================================================================
9Ô∏è‚É£ FORMULA: 1D ‚Üí 2D INDEX CONVERSION
===============================================================================

Given:
- index
- columns = C

Row index:
i = index / C

Column index:
j = index % C

This works because of:
üëâ zero-based indexing

===============================================================================
üîü ADDRESS CALCULATION (HOW CPU ACCESSES DATA)
===============================================================================

CPU does NOT understand rows and columns.
CPU only understands ADDRESSES.

Formula:

Address = BaseAddress + (index √ó size_of_element)

For 2D array:

Address = Base + ((i √ó C + j) √ó size_of_element)

This is why:
üëâ number of columns MUST be known at compile time

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ DECLARATION OF 2D ARRAY IN C++
===============================================================================

int arr[4][3];

Means:
- 4 rows
- 3 columns
- Total elements = 12

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ INITIALIZATION
===============================================================================

int arr[4][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
    {10, 11, 12}
};

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ ACCESSING & UPDATING ELEMENTS
===============================================================================

arr[3][0] = 15;   // Update
cin >> arr[1][2]; // User input

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ TRAVERSING A 2D ARRAY (ROW-WISE)
===============================================================================

for(int i = 0; i < rows; i++)
{
    for(int j = 0; j < cols; j++)
    {
        cout << arr[i][j] << " ";
    }
    cout << endl;
}

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ SEARCH AN ELEMENT IN 2D ARRAY
===============================================================================

bool found = false;

for(int i = 0; i < rows; i++)
{
    for(int j = 0; j < cols; j++)
    {
        if(arr[i][j] == x)
        {
            found = true;
            break;
        }
    }
}

Time Complexity: O(rows √ó cols)
Space Complexity: O(1)

===============================================================================
1Ô∏è‚É£6Ô∏è‚É£ ADDITION OF TWO MATRICES
===============================================================================

Condition:
Rows and columns must be SAME.

answer[i][j] = a[i][j] + b[i][j]

Time Complexity: O(rows √ó cols)
Space Complexity: O(rows √ó cols)

===============================================================================
1Ô∏è‚É£7Ô∏è‚É£ ROW WITH MAXIMUM SUM
===============================================================================

Approach:
- Calculate sum of each row
- Track maximum sum
- Store row index

Time Complexity: O(rows √ó cols)
Space Complexity: O(1)

===============================================================================
1Ô∏è‚É£8Ô∏è‚É£ DIAGONAL SUM (SQUARE MATRIX ONLY)
===============================================================================

Primary diagonal:
arr[i][i]

Secondary diagonal:
arr[i][n - i - 1]

Time Complexity: O(n)
Space Complexity: O(1)

===============================================================================
1Ô∏è‚É£9Ô∏è‚É£ REVERSE EACH ROW OF MATRIX
===============================================================================

For each row:
- Use two pointers
- Swap start and end

Time Complexity: O(rows √ó cols)
Space Complexity: O(1)

===============================================================================
üéØ FINAL TAKEAWAYS
===============================================================================

‚úî 2D arrays store tabular data
‚úî Internally stored as linear memory
‚úî Row-major order in C++
‚úî Address calculation is critical
‚úî Foundation of matrices, DP, graphs, games

Next lecture:
üëâ 2D Arrays with VECTORS (Dynamic size)

JAI HIND üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
