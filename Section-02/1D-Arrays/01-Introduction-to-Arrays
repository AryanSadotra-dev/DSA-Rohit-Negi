/*
===============================================================================
üìò DSA LECTURE NOTES ‚Äì DAY 22
INTRODUCTION TO ARRAYS (DSA ‚Äì 180 Days Coding Challenge)
(Complete Classroom Reconstruction ‚Äì English ‚Äì GitHub Ready)
===============================================================================

‚ö†Ô∏è These notes are NOT a definition dump.
‚ö†Ô∏è These notes reconstruct the teacher‚Äôs thinking process.
‚ö†Ô∏è Real-life stories are intentionally used.
‚ö†Ô∏è Arrays + Memory + Addressing + Why 0-based indexing is covered.
‚ö†Ô∏è This lecture builds strong CS fundamentals.

===============================================================================
0Ô∏è‚É£ LECTURE INTRODUCTION
===============================================================================

Hello Code Army, how are you all?

Today, FINALLY, our DSA series begins üéâ  
This is Day 22 of the 180 Days of Code Challenge.

Today‚Äôs topic:
üëâ INTRODUCTION TO ARRAYS

We will NOT learn arrays in a boring way.
We will understand:
- What arrays are
- Why arrays were needed
- How arrays are implemented
- How memory works behind arrays
- Why indexing starts from 0
- Why arrays use contiguous memory

Let‚Äôs begin with a story.

===============================================================================
1Ô∏è‚É£ STORY ‚Äì THE STORE ROOM ANALOGY (WHY ARRAYS EXIST)
===============================================================================

Imagine you are a new shopkeeper.
You sell apples.

You bring a LOT of apples.
Now you need a place to store them.

You find a man who owns many store rooms:
Room 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...

Initially:
- You rent room 6
- Later you rent room 3
- Later you rent room 9

Now your data looks like:
üëâ Apples stored at rooms: 6, 3, 9

Problem:
‚ùå You must remember all room numbers individually

Later, your business grows.
You need 10 rooms together.

You ask:
‚ÄúI want 10 rooms CONTINUOUSLY, not scattered.‚Äù

The owner gives:
Rooms 3 to 12 (10 rooms)

Now your data is:
- Starting room = 3
- Total rooms = 10

‚úÖ You don‚Äôt need to remember all numbers
‚úÖ You can access any room easily
‚úÖ Everything is together

üí° THIS is the core idea of an ARRAY.

===============================================================================
2Ô∏è‚É£ WHY NORMAL VARIABLES FAIL
===============================================================================

Problem:
üëâ Find sum of numbers.

Case 1:
3 numbers ‚Üí a, b, c (OK)

Case 2:
10 numbers ‚Üí a, b, c, d, e, f, g, h, i, j (Messy)

Case 3:
100 numbers ‚Üí Impossible to manage names
Case 4:
1000 numbers ‚Üí Nightmare

‚ùå Writing variable names is not scalable
‚ùå Code becomes unmanageable

We want:
- Same type of data
- Many values
- Easy access
- Automatic indexing

‚û°Ô∏è ARRAY solves this.

===============================================================================
3Ô∏è‚É£ WHAT IS AN ARRAY? (REAL DEFINITION)
===============================================================================

An ARRAY:
- Stores SAME TYPE of data
- Stores data at CONTIGUOUS MEMORY LOCATIONS
- Uses INDEXING to access elements

Example:
int arr[5];

This creates:
- One name (arr)
- Five integers
- Stored together in memory

===============================================================================
4Ô∏è‚É£ ARRAY DECLARATION
===============================================================================

Syntax:

    data_type array_name[size];

Example:

    int arr[1000];

Meaning:
- arr is an array
- Size = 1000
- Stores ONLY int values

===============================================================================
5Ô∏è‚É£ ARRAY INITIALIZATION METHODS
===============================================================================

----------------------------------------
METHOD 1: Direct Initialization
----------------------------------------

int arr[5] = {6, 8, 5, 1, 9};

Indexes:
arr[0] = 6
arr[1] = 8
arr[2] = 5
arr[3] = 1
arr[4] = 9

----------------------------------------
METHOD 2: Auto Size Deduction
----------------------------------------

int arr[] = {2, 8, 10, 9};

Compiler decides size = 4

----------------------------------------
METHOD 3: User Input
----------------------------------------

int arr[10];

for(int i = 0; i < 10; i++)
{
    cin >> arr[i];
}

----------------------------------------
METHOD 4: Partial Initialization
----------------------------------------

int arr[5] = {4, 7};

Remaining elements contain garbage values.

----------------------------------------
METHOD 5: Zero Initialization
----------------------------------------

int arr[5] = {0};

ALL elements become 0.

‚ö†Ô∏è Works ONLY with zero.

===============================================================================
6Ô∏è‚É£ INDEXING IN ARRAYS
===============================================================================

Indexing starts from 0.

For size = n:
Valid indices = 0 to n-1

Example:
int arr[5];

Valid:
arr[0] to arr[4]

Invalid:
arr[5] ‚ùå (Out of bounds)

Out-of-bounds access leads to:
‚ùå Garbage values
‚ùå Undefined behavior

===============================================================================
7Ô∏è‚É£ WHY CONTIGUOUS MEMORY?
===============================================================================

Imagine memory as houses with addresses:

Byte-addressable memory:
Each byte has a unique address.

If:
- int = 4 bytes
- arr starts at address 500

Then:
arr[0] ‚Üí 500
arr[1] ‚Üí 504
arr[2] ‚Üí 508
arr[3] ‚Üí 512
arr[4] ‚Üí 516

Pattern:
Each element is next to the previous.

This allows:
- Fast access
- Easy address calculation
- Less memory tracking

===============================================================================
8Ô∏è‚É£ ADDRESS CALCULATION FORMULA
===============================================================================

Address of arr[i]:

    base_address + (index √ó size_of_data_type)

This formula works ONLY because memory is contiguous.

===============================================================================
9Ô∏è‚É£ WHY 0-BASED INDEXING?
===============================================================================

Using 0-based indexing:
- Requires fewer operations
- Simpler address calculation
- Faster execution

1-based indexing would require:
(index - 1) √ó size ‚Üí extra operation

Hence:
0-based indexing is preferred.

===============================================================================
üîü BYTE ADDRESSABLE MEMORY
===============================================================================

- 1 byte = 8 bits
- Each byte has a unique address
- Memory is accessed using addresses

CPU sends address instructions to fetch data.

===============================================================================
1Ô∏è‚É£1Ô∏è‚É£ 32-BIT vs 64-BIT SYSTEM (IMPORTANT)
===============================================================================

32-bit system:
- Can address 2^32 bytes ‚âà 4GB RAM

64-bit system:
- Can address much more memory
- Supports 8GB, 16GB, 32GB, etc.

Meaning of ‚Äú64-bit‚Äù:
üëâ CPU can generate 64-bit addresses

===============================================================================
1Ô∏è‚É£2Ô∏è‚É£ FINDING MINIMUM ELEMENT IN ARRAY
===============================================================================

Approach:
- Initialize answer with INT_MAX
- Compare every element
- Update if smaller found

Code:

int minVal = INT_MAX;

for(int i = 0; i < n; i++)
{
    if(arr[i] < minVal)
        minVal = arr[i];
}

===============================================================================
1Ô∏è‚É£3Ô∏è‚É£ FINDING MAXIMUM ELEMENT IN ARRAY
===============================================================================

Approach:
- Initialize answer with INT_MIN
- Compare every element
- Update if larger found

Code:

int maxVal = INT_MIN;

for(int i = 0; i < n; i++)
{
    if(arr[i] > maxVal)
        maxVal = arr[i];
}

===============================================================================
1Ô∏è‚É£4Ô∏è‚É£ sizeof ARRAY TRICK
===============================================================================

Total array size in bytes:

    sizeof(arr)

Size of one element:

    sizeof(arr[0])

Number of elements:

    sizeof(arr) / sizeof(arr[0])

===============================================================================
1Ô∏è‚É£5Ô∏è‚É£ WHY ARRAYS ARE IMPORTANT IN DSA
===============================================================================

- Foundation of DSA
- Used in:
  - Sorting
  - Searching
  - Prefix sums
  - Sliding window
  - Two pointers
  - Dynamic Programming

Without arrays:
‚ùå DSA is impossible

===============================================================================
üéØ FINAL TAKEAWAY
===============================================================================

Arrays:
- Store same type data
- Use contiguous memory
- Allow fast access
- Reduce complexity
- Make DSA possible

Today you learned:
‚úî Arrays
‚úî Memory
‚úî Addressing
‚úî Indexing
‚úî Min / Max logic
‚úî Why 32-bit & 64-bit matter

This is REAL computer science.

JAI HIND üáÆüá≥
===============================================================================
END OF FILE
===============================================================================
*/
