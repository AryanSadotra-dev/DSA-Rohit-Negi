/*
====================================================================
ğŸ“˜ Lecture Notes
Character Pointers, Void Pointers, Functions, and Passing Mechanisms in C++
(Full Classroom Teaching Style â€“ Exact Reconstruction in English)
====================================================================

These notes are a direct reconstruction of the lecture delivered in class.
The flow, repetition, reasoning, and explanations follow the teacher exactly.
Nothing is summarized. Nothing is skipped.
Concepts are explained multiple times where the teacher repeated them.

--------------------------------------------------------------------
1. Setting the Context (What We Have Studied So Far)
--------------------------------------------------------------------
The teacher begins by reconnecting with previous lectures.

Until now, we have already studied pointers.

A pointer is a variable that stores an address.
It does NOT store the value directly.
It stores the memory location where the value is stored.

This point is repeated multiple times by the teacher.

Pointers are type-specific:
- Address of int is stored in int*
- Address of char is stored in char*
- Address of float is stored in float*
- Address of double is stored in double*

Then arrays were discussed.

In arrays, the teacher explained a very important rule:
The name of the array stores the address of the 0th index element.

So:
arr == &arr[0]

Then pointer arithmetic was covered.
Pointers move in memory based on the size of the data type.

After reminding all this, the teacher says:
â€œToday we will see how pointers behave with character arrays.â€

--------------------------------------------------------------------
2. Introducing Character Array Slowly
--------------------------------------------------------------------
The teacher writes:

char arr[5] = {'1', '2', '3', '4'};

Then he immediately pauses.

He asks:
â€œWhy size is 5 but only 4 characters?â€

Explanation:
A character array always reserves one extra space for the null character '\0'.

So:
Index 0 â†’ '1'
Index 1 â†’ '2'
Index 2 â†’ '3'
Index 3 â†’ '4'
Index 4 â†’ '\0'

The null character is automatically inserted by the compiler.
We do NOT write it manually.

If fewer characters are inserted, the remaining position still gets '\0'.

This null character is extremely important.

--------------------------------------------------------------------
3. Memory-Level Explanation of Character Array
--------------------------------------------------------------------
The teacher now explains memory layout.

Assume:
arr[0] is stored at address 500.

Since char takes 1 byte:

Index   Value   Address
0       '1'     500
1       '2'     501
2       '3'     502
3       '4'     503
4       '\0'    504

He compares this with int arrays.

int takes 4 bytes, so addresses jump by 4.

In char:
Addresses increase by 1.

He repeats:
â€œThe array name stores the address of the first element.â€

So:
arr = 500

--------------------------------------------------------------------
4. Storing Array Address in a Pointer
--------------------------------------------------------------------
Now the teacher writes:

char* ptr = arr;

Explanation:
- ptr is a character pointer
- It stores an address
- That address is 500
- It points to character-type data

Now:
arr = 500
ptr = 500

Both store the same address.

--------------------------------------------------------------------
5. The Big Question: What Happens When We Print?
--------------------------------------------------------------------
The teacher asks:

â€œIf I do cout << arr; what will print?â€
â€œIf I do cout << ptr; what will print?â€

Students think:
Both store address â†’ address should print

Teacher pauses and challenges this thinking.

--------------------------------------------------------------------
6. Actual Code Execution and Shock Output
--------------------------------------------------------------------
Code executed:

#include <iostream>
using namespace std;

int main() {
    char arr[5] = {'1', '2', '3', '4'};
    char* ptr = arr;

    cout << arr << endl;
    cout << ptr << endl;
}

Output:
1234
1234

Students are shocked.

--------------------------------------------------------------------
7. Why Did This Happen? (Character Array Special Rule)
--------------------------------------------------------------------
Teacher explains slowly.

Rule:
When cout receives an address of character data,
it does NOT print the address.

Instead:
It starts printing characters until it finds '\0'.

Step-by-step:
Address 500 â†’ '1' â†’ print
Address 501 â†’ '2' â†’ print
Address 502 â†’ '3' â†’ print
Address 503 â†’ '4' â†’ print
Address 504 â†’ '\0' â†’ STOP

This behavior is hardcoded for char pointers.

--------------------------------------------------------------------
8. Why Pointer Also Prints Values
--------------------------------------------------------------------
ptr stores an address.
That address points to character data.

cout sees a character pointer.
Same rule applies.

So:
cout << ptr;
prints characters until '\0'.

--------------------------------------------------------------------
9. Forcing Address Printing (Void Pointer Trick)
--------------------------------------------------------------------
To print address:

cout << (void*)arr << endl;
cout << (void*)ptr << endl;

Now address prints.

Reason:
void* has no type information.
cout has no special behavior for void*.

This is type casting.

--------------------------------------------------------------------
10. What Is a Void Pointer?
--------------------------------------------------------------------
A void pointer:
- Stores an address
- Does NOT know the data type

Casting char* to void* removes character interpretation.

--------------------------------------------------------------------
11. Single Character Variable Case
--------------------------------------------------------------------
Example:

char name = 'A';
char* ptr = &name;

cout << ptr;

This prints garbage.

Reason:
cout keeps printing memory until it finds '\0'.

Correct way:
cout << (void*)ptr;

--------------------------------------------------------------------
12. Compiler Dependency Note
--------------------------------------------------------------------
Some compilers may print address accidentally.
This is NOT standard behavior.

Standard C++:
Character pointers print data, not address.

--------------------------------------------------------------------
13. Transition to Functions
--------------------------------------------------------------------
Teacher moves to functions.

Example:

int num = 10;

Stored at address 200.

Function:

void increment(int n) {
    n++;
}

Call:
increment(num);

Result:
num remains 10.

Reason:
Pass by value.
New memory created.

--------------------------------------------------------------------
14. Solving Using Pointer (Pass by Pointer)
--------------------------------------------------------------------
Function:

void increment(int* ptr) {
    (*ptr)++;
}

Call:
increment(&num);

Now:
ptr stores address 200.
*ptr modifies actual memory.

num becomes 11.

--------------------------------------------------------------------
15. Arrays in Functions
--------------------------------------------------------------------
Example:

int arr[5] = {1,2,3,4,5};

Function:

void doubleArr(int* p) {
    for(int i=0;i<5;i++)
        p[i] *= 2;
}

Array name passes address.
Changes affect original array.

--------------------------------------------------------------------
16. Swapping Using Pointers
--------------------------------------------------------------------
Swap function:

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

Addresses allow direct memory modification.

--------------------------------------------------------------------
17. Reference Variables
--------------------------------------------------------------------
Example:

int num = 10;
int& ref = num;

ref is another name for same memory.
No new memory allocated.

ref++;
num becomes 11.

--------------------------------------------------------------------
18. Pass by Reference
--------------------------------------------------------------------
Swap using reference:

void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

Cleaner syntax.
Same memory behavior.

--------------------------------------------------------------------
19. Final Concept Lock
--------------------------------------------------------------------
Pass by value â†’ No memory change
Pass by pointer â†’ Address-based change
Pass by reference â†’ Clean memory sharing

Teacher advice:
Understand memory deeply before syntax.

====================================================================
END OF LECTURE NOTES
====================================================================
*/
